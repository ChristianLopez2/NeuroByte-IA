<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>RAG Licitaciones – Front</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Usa tu CSS principal -->
  <link rel="stylesheet" href="/static/styles.css">
  <link rel="icon" href="/static/favicon.png" type="image/png">
</head>
<body>
<div class="chat-shell">
    <div class="chat-topbar">
      <div class="brand">Asistente NeuroByte-IA</div>
    </div>

    <div class="chat-container">
      <section>
        <h2 class="section-title">Analizador de Procesos/Licitaciones</h2>

        <!-- NUEVO: selector de proceso -->
        <div class="row">
          <label for="process" class="tiny" style="min-width:160px">Tipo de Proceso/Licitación: </label>
          <select id="process" class="input" style="max-width:520px">
            <option value="auto" selected>Detección automática</option>
          </select>
        </div>

        <div class="row">
          <input id="q" class="input" type="text" placeholder="Podemos ayudarte en algo mas? Cuentanos... (Opcional)" />
          <button id="ask" class="btn">Analizar</button>
        </div>
        <div id="chat" class="chat-box"></div>
      </section>
      <!-- Barra de progreso (autosuficiente) -->
      <div id="pwrap" style="display:none; margin-top:12px;">
        <div style="height:10px;background:#16213a;border-radius:10px;overflow:hidden;">
          <div id="pbar" style="height:10px;width:0%;background:#46a6ff;transition:width .25s ease;"></div>
        </div>
        <div id="ptext" style="font-size:.9rem;margin-top:6px;opacity:.85;">Preparando…</div>
      </div>

      <section class="u-mt">
        <h2 class="section-title">Cargar Licitaciones</h2>
        <div class="row">
          <input id="files" type="file" accept="application/pdf" />
          <button id="upload" class="btn">Subir</button>
          <span id="status" class="tiny"></span>
        </div>
        <div id="list" class="tiny">No hay archivos aún.</div>
      </section>
    </div>
  </div>


<script>
// ===== Config =====
const API_BASE = localStorage.getItem("API_BASE") || "http://127.0.0.1:8000";


// ===== Helpers UI =====
const $chat = document.getElementById("chat");
const $q    = document.getElementById("q");
const $files= document.getElementById("files");
const $list = document.getElementById("list");
const $status = document.getElementById("status");

const $process = document.getElementById("process");
let lastProcessSelection = localStorage.getItem("processSelection") || "auto";

function addMsg(text, cls="bot"){
  const div = document.createElement("div");
  div.className = `msg ${cls}`;
  div.innerHTML = text;
  $chat.appendChild(div);
  $chat.scrollTop = $chat.scrollHeight;
}
function addUser(text){ addMsg(escapeHtml(text), "user"); }
function addBot(text){ addMsg(text, "bot"); }

function escapeHtml(str){
  return String(str).replace(/[&<>"'`=\/]/g, s => (
    {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','/':'&#x2F;','`':'&#x60;','=':'&#x3D;'}[s]
  ));
}

function pretty(obj){
  try{ return `<pre>${JSON.stringify(obj, null, 2)}</pre>`; }
  catch{ return `<pre>${obj}</pre>`; }
}
// === NUEVOS HELPERS ===
function renderSnapshot(html){
  // mantiene un único bloque consolidado de resultados
  let host = document.getElementById("analysis-snapshot");
  if(!host){
    host = document.createElement("div");
    host.id = "analysis-snapshot";
    host.className = "msg bot";
    $chat.appendChild(host);
  }
  host.innerHTML = html;
  $chat.scrollTop = $chat.scrollHeight;
}

function formatNarrative(text){
  if(!text) return "—";
  const esc = escapeHtml(text);
  return `<pre style="white-space:pre-wrap;margin:0">${esc}</pre>`;
}


// ===== API calls =====
async function apiPost(path, body){
  const r = await fetch(`${API_BASE}${path}`, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(body || {})
  });
  if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
  return r.json();
}
async function apiGet(path){
  const r = await fetch(`${API_BASE}${path}`);
  if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
  return r.json();
}
async function apiUpload(path, files){
  const fd = new FormData();
  for(const f of files) fd.append("files", f);
  const r = await fetch(`${API_BASE}${path}`, { method:"POST", body: fd });
  if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
  return r.json();
}

// ===== Procesos ===== (NUEVO)
async function loadProcesses() {
  try {
    const r = await apiGet("/api/processes"); // requiere el endpoint sugerido
    const items = (r && r.items) ? r.items : [];
    populateProcessCombo(items);
  } catch (e) {
    // Fallback: lista mínima por si el endpoint no existe aún
    const fallback = [
      { familia: "bienes_servicios", procedimiento: "Cotizacion" },
      { familia: "bienes_servicios", procedimiento: "Licitacion" },
      { familia: "bienes_servicios", procedimiento: "Menor Cuantia" },
      { familia: "consultoria", procedimiento: "Licitacion" },
      { familia: "obras", procedimiento: "Cotizacion" },
      { familia: "obras", procedimiento: "Menor Cuantia" },
      { familia: "seguros", procedimiento: "Licitacion" },
      { familia: "regimen_especial", procedimiento: "Pliego" },
    ];
    populateProcessCombo(fallback);
  }
}

function populateProcessCombo(items){
  // conservar "auto"
  const current = localStorage.getItem("processSelection");
  // limpia todo salvo el primer option
  for(let i = $process.options.length - 1; i >= 1; i--) $process.remove(i);

  items.forEach(p => {
    const text = `${labelFamilia(p.familia)} — ${labelProc(p.procedimiento)}`;
    const opt = document.createElement("option");
    opt.value = JSON.stringify({ familia: p.familia, procedimiento: p.procedimiento });
    opt.textContent = text;
    $process.appendChild(opt);
  });

  if (current) {
    // intenta restaurar
    const idx = [...$process.options].findIndex(o => o.value === current);
    if (idx >= 0) $process.selectedIndex = idx;
  }
    // Si hay un proceso detectado pendiente, aplícalo ahora
  if (__pendingDetectedProcess) {
    setProcessSelection(__pendingDetectedProcess);
    __pendingDetectedProcess = null;
  }

}

function labelFamilia(f){
  const map = {
    bienes_servicios: "Bienes y Servicios",
    consultoria: "Consultoría",
    obras: "Obras",
    seguros: "Licitación de Seguros",
    regimen_especial: "Régimen Especial"
  };
  return map[f] || f || "—";
}
function labelProc(p){
  const map = {
    Cotizacion: "Cotización",
    Licitacion: "Licitación",
    "Menor Cuantia": "Menor Cuantía",
    "Subasta Inversa Electrónica": "Subasta Inversa Electrónica",
    Pliego: "Pliego"
  };
  return map[p] || p || "—";
}

function getSelectedProcess(){
  const v = $process.value;
  if (!v || v === "auto") return null;
  try { return JSON.parse(v); } catch { return null; }
}

// guarda selección y notifica al backend
$process.addEventListener("change", async () => {
  const selected = $process.value || "auto";

  try {
    const res = await fetch(`${API_BASE}/api/cambioTipoDoc?process=${encodeURIComponent(selected)}`, {
      method: "GET"
    });

    if (res.status === 204) {
      localStorage.setItem("processSelection", selected);
      lastProcessSelection = selected;
      if ($chat) $chat.textContent = "";
      $list.textContent = "No hay archivos aún.";
    } else {
      $process.value = lastProcessSelection;
    }
  } catch (e) {
    $process.value = lastProcessSelection;
  }
});

// ===== Auto-proceso detectado =====
let __pendingDetectedProcess = null; // por si llegan antes de poblar el combo

function setProcessSelection(proc){
  if (!proc || !proc.familia || !proc.procedimiento) return false;

  const wantedObj = { familia: proc.familia, procedimiento: proc.procedimiento };
  const wanted = JSON.stringify(wantedObj);

  // 1) Intenta seleccionar por value directamente
  $process.value = wanted;

  // 2) Si no existe esa opción, créala on-the-fly y selecciónala
  if ($process.value !== wanted) {
    const txt = `${labelFamilia(proc.familia)} — ${labelProc(proc.procedimiento)}`;
    const opt = new Option(txt, wanted);
    $process.add(opt);
    $process.value = wanted;
  }

  // 3) Asegura que “auto” no quede visualmente marcado
  if ($process.options[0]) $process.options[0].selected = false;

  // 4) Persistencia local (no disparamos 'change', así no se limpia nada)
  localStorage.setItem("processSelection", wanted);
  lastProcessSelection = wanted;

  // 5) Mensaje (opcional)
  addBot(`🔎 Tipo detectado: ${labelFamilia(proc.familia)} — ${labelProc(proc.procedimiento)}`);

  // 6) (Opcional) fuerza re-pintado sin side-effects
  $process.dispatchEvent(new Event("input"));

  return true;
}

async function hydrateDetectedProcess(){
  try {
    const r = await apiGet("/api/process-hint");
    const p = r && r.process;
    if (p) {
      // Si aún no está el combo poblado, guárdalo para aplicarlo luego
      if (!setProcessSelection(p)) {
        __pendingDetectedProcess = p;
      }
    }
  } catch {}
}


// ===== Events =====

// ===== Render helpers (nuevos) =====
const SEM_COLORS = {
  "aprobado":   "#2ecc71",
  "faltan_requisitos": "#f1c40f",
  "no_cumple":  "#e74c3c",
  "": "#7f8c8d", "nd": "#7f8c8d", "n/d":"#7f8c8d"
};

const html = (s)=>s; // sintaxis azucar, ya usamos escape donde toca

function colorBySemaforo(s){
  const k=(s||"").toLowerCase();
  return SEM_COLORS[k] || "#7f8c8d";
}
function badgeSemaforo(semaforo, archivo){
  const c = colorBySemaforo(semaforo);
  const label = (semaforo||"N/D").replace(/_/g," ").toUpperCase();
  return html(`
    <span class="badge" style="--b:${c}">
      <b style="color:${c}">${label}</b> — ${escapeHtml(archivo||"Oferta")}
    </span>
  `);
}
function formatNarrative(text){
  if(!text) return "—";
  // líneas → <br>; bullets con "-" → <ul>
  const lines = String(text).split(/\r?\n/).map(x=>x.trim());
  const groups = [];
  let ul = [];
  for(const ln of lines){
    if(/^[-•]\s+/.test(ln)) ul.push(escapeHtml(ln.replace(/^[-•]\s+/, "")));
    else{
      if(ul.length){ groups.push(`<ul class="bullets-compact">${ul.map(li=>`<li>${li}</li>`).join("")}</ul>`); ul=[]; }
      if(ln) groups.push(`<p>${escapeHtml(ln)}</p>`);
    }
  }
  if(ul.length) groups.push(`<ul class="bullets-compact">${ul.map(li=>`<li>${li}</li>`).join("")}</ul>`);
  return groups.join("");
}
function cardNarrativa({archivo, texto}, semaforo){
  const color = colorBySemaforo(semaforo);
  return html(`
    <div class="card rcard">
      <div class="rcard-hd">
        <div class="rcard-title">🗂️ ${escapeHtml(archivo||"Oferta")}</div>
        <span class="tag" style="--b:${color};color:${color}">${(semaforo||"N/D").replace(/_/g," ").toUpperCase()}</span>
      </div>
      <div class="rcard-body">${formatNarrative(texto)}</div>
    </div>
  `);
}
function cardDecision(archivo, json){
  const body = `<pre class="json">${escapeHtml(JSON.stringify(json||{}, null, 2))}</pre>`;
  return html(`
    <details class="card det">
      <summary>🧾 JSON de decisión — ${escapeHtml(archivo||"Oferta")}</summary>
      ${body}
    </details>
  `);
}
function bannerComparativo(texto){
  if(!texto) return "";
  return html(`
    <div class="cmp">
      <div class="cmp-title">📊 Comparativo</div>
      <div class="cmp-text">${escapeHtml(texto)}</div>
    </div>
  `);
}

// ===== Nuevo handler de Analizar =====

document.getElementById("ask").onclick = async () => {
  const btn = document.getElementById("ask");
  const query = $q.value.trim();            // puede ir vacío
  const process = getSelectedProcess();      // toma del combo "Tipo de proceso"

  if (query) addUser(query);                 // pinta mensaje del usuario (si escribió algo)

  btn.disabled = true;
  startProgress();

  try {
    const data = await apiPost("/api/chat", { query, process });

    // Si solo viene respuesta de chat (consulta sobre cache), mostrarla y salir
    if (typeof data?.respuesta_chat === "string" && data.respuesta_chat.trim()) {
      // snapshot simple de texto
      renderSnapshot(`<div class="msg bot">${escapeHtml(data.respuesta_chat)}</div>`);
      return;
    }

    const r1 = data?.respuesta1 || {};
    const r2 = data?.respuesta2 || {};
    let htmlOut = "";

    // ===== Semáforos (badges arriba) =====
    const semBadges = (r2.por_archivo || []).map(x=>{
      const arch = x?.archivo || "Oferta";
      const sem  = (x?.json?.semaforo || "").toLowerCase();
      const color =
        sem === "aprobado" ? "#2ecc71" :
        sem === "faltan_requisitos" ? "#f1c40f" :
        sem === "no_cumple" ? "#e74c3c" : "#7f8c8d";
      return `<span style="display:inline-block;padding:.1rem .5rem;border-radius:999px;background:${color}22;border:1px solid ${color};margin:.15rem .25rem .15rem 0">
        <b style="color:${color}">${(sem||"N/D").replace(/_/g," ").toUpperCase()}</b> — ${escapeHtml(arch)}
      </span>`;
    }).join("");
    if (semBadges) htmlOut += `<div style="margin-bottom:.35rem">${semBadges}</div>`;

    // ===== Comparativo (una sola vez) =====
    if (r1.comparativo_texto){
      htmlOut += `
        <div style="border:1px dashed #2d3b6a;border-radius:12px;padding:10px;margin:.25rem 0 .6rem 0;background:#0f1a33;">
          <div style="font-weight:700;margin-bottom:4px">📊 Comparativo</div>
          <div>${escapeHtml(r1.comparativo_texto)}</div>
        </div>`;
    }

    // ===== Narrativa por archivo (cards) =====
    const semIndex = Object.fromEntries((r2.por_archivo||[]).map(x=>[x.archivo, (x.json?.semaforo||"")]));
    if (r1.por_archivo?.length){
      htmlOut += `<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px">`;
      r1.por_archivo.forEach(({ archivo, texto })=>{
        const status = (semIndex[archivo]||"N/D").replace(/_/g," ").toUpperCase();
        const color =
          (semIndex[archivo]||"").toLowerCase()==="aprobado" ? "#2ecc71" :
          (semIndex[archivo]||"").toLowerCase()==="faltan_requisitos" ? "#f1c40f" :
          (semIndex[archivo]||"").toLowerCase()==="no_cumple" ? "#e74c3c" : "#7f8c8d";
        htmlOut += `
          <div class="card" style="background:#10162a;border:1px solid #1b2442;border-radius:14px;padding:12px">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:6px">
              <div style="font-weight:700">🗂️ ${escapeHtml(archivo || "Oferta")}</div>
              <span style="display:inline-block;padding:.08rem .5rem;border-radius:999px;border:1px solid ${color};color:${color};background:${color}22;font-size:.85rem">${status}</span>
            </div>
            <div>${formatNarrative(texto)}</div>
          </div>`;
      });
      htmlOut += `</div>`;
    } else {
      htmlOut += `<div class="msg bot">🤷 No hay narrativa para mostrar.</div>`;
    }

    // ===== JSON de decisión (details por archivo) =====
    if (r2.por_archivo?.length){
      const blocJ = r2.por_archivo.map(({ archivo, json })=>{
        const jsonStr = JSON.stringify(json ?? {}, null, 2);
        return `
          <details style="margin-top:12px" class="card">
            <summary style="cursor:pointer">🧾 JSON de decisión — ${escapeHtml(archivo||"Oferta")}</summary>
            <pre style="white-space:pre-wrap;margin:.5rem 0 0 0">${escapeHtml(jsonStr)}</pre>
          </details>`;
      }).join("");
      htmlOut += `<div>${blocJ}</div>`;
    } else {
      htmlOut += `<div class="msg bot">🧩 No se generó JSON de decisión.</div>`;
    }

    // ===== Un solo render consolidado (sin duplicar) =====
    renderSnapshot(htmlOut);

  } catch (e) {
    renderSnapshot(`⚠️ Error /api/chat<br>${escapeHtml(e.message)}`);
  } finally {
    stopProgress(true);
    btn.disabled = false;
    $q.value = ""; // limpia el campo
  }
};

document.getElementById("upload").onclick = async ()=>{
  const files = $files.files;
  if(!files || !files.length) return;
  $status.textContent = "Subiendo...";
  try{
    const data = await apiUpload("/api/upload-pdf", files);
    $status.textContent = "✅ Listo";
    addBot(`Subidos: ${data.files.map(x=>x.filename).join(", ")}`);
    await refreshList();
    // Si el backend detectó el proceso en el primer PDF, aplícalo
    if (data.detected_process) {
      if (!setProcessSelection(data.detected_process)) {
        __pendingDetectedProcess = data.detected_process; // por si el combo aún no está listo
      }
    }

  }catch(e){
    $status.textContent = "⚠️ Error al subir";
    addBot(`⚠️ Error /api/upload-pdf<br>${escapeHtml(e.message)}`);
  }finally{
    setTimeout(()=> $status.textContent="", 1500);
    $files.value = "";
  }
};

async function refreshList(){
  try{
    const data = await apiGet("/api/list-pdf");
    if(!data.files || !data.files.length){
      $list.textContent = "No hay archivos aún.";
      return;
    }
    $list.innerHTML = data.files.map(f => (
      `<span class="chip">${escapeHtml(f.filename)} · ${humanSize(f.size_bytes||0)}</span>`
    )).join("");
  }catch(e){
    $list.textContent = "⚠️ Error listando PDFs";
  }
}

function humanSize(bytes){
  const units = ['B','KB','MB','GB','TB'];
  let i = 0, n = Math.max(0, bytes);
  while(n >= 1024 && i < units.length-1){ n/=1024; i++; }
  return `${n.toFixed(n >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
}
// === Progreso (inline, sin tocar tu CSS global) ===
function startProgress(){
  const wrap = document.getElementById('pwrap'); if (!wrap) return;
  wrap.style.display='block';
  setProgress(5, 'Preparando…');

  // simulación por fases hasta 90% mientras esperamos
  const phases = [
    {to: 20, text: 'Leyendo archivos…'},
    {to: 45, text: 'Indexando oferta…'},
    {to: 70, text: 'Seleccionando BASE…'},
    {to: 90, text: 'Construyendo contexto…'}
  ];
  let idx = 0;
  window.__pTimer && clearInterval(window.__pTimer);
  window.__pPct = 5;

  window.__pTimer = setInterval(()=>{
    const target = phases[Math.min(idx, phases.length-1)].to;
    if (window.__pPct < target) {
      window.__pPct = Math.min(target, window.__pPct + 2);
      setProgress(window.__pPct, phases[idx].text);
    } else {
      idx = Math.min(idx+1, phases.length-1);
    }
  }, 300);
}
function setProgress(pct, text){
  const bar = document.getElementById('pbar'); if (bar) bar.style.width = pct + '%';
  const txt = document.getElementById('ptext'); if (txt && text) txt.textContent = text;
}
function stopProgress(ok=true){
  window.__pTimer && clearInterval(window.__pTimer);
  setProgress(100, ok ? 'Análisis completado' : 'Error en el análisis');
  const wrap = document.getElementById('pwrap');
  if (wrap) setTimeout(()=>{ wrap.style.display='none'; setProgress(0,''); }, 900);
}

refreshList();
loadProcesses().then(hydrateDetectedProcess);
</script>



</body>
</html>
